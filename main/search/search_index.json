{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#motivation","title":"Motivation","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>arkas</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>arkas</code> to a new version will possibly break any code that was using the old version of <code>arkas</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>arkas</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install arkas\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>arkas</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'arkas[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install arkas numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>arkas</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/arkas.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate arkas\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>arkas</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/data/","title":"arkas.data","text":""},{"location":"refs/data/#arkas.data.ingestor","title":"arkas.data.ingestor","text":"<p>Contain the data ingestor.</p>"},{"location":"refs/data/#arkas.data.ingestor.BaseIngestor","title":"arkas.data.ingestor.BaseIngestor","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to ingest data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; from arkas.data.ingestor import DataFrameIngestor\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; ingestor = DataFrameIngestor(ingestor=Ingestor(frame))\n&gt;&gt;&gt; ingestor\nDataFrameIngestor(\n  (ingestor): Ingestor(shape=(5, 3))\n)\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/data/#arkas.data.ingestor.BaseIngestor.ingest","title":"arkas.data.ingestor.BaseIngestor.ingest","text":"<pre><code>ingest() -&gt; dict\n</code></pre> <p>Ingest the data.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The ingested data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; from arkas.data.ingestor import DataFrameIngestor\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; ingestor = DataFrameIngestor(ingestor=Ingestor(frame))\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/data/#arkas.data.ingestor.DataFrameIngestor","title":"arkas.data.ingestor.DataFrameIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The DataFrame ingestor or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; from arkas.data.ingestor import DataFrameIngestor\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; ingestor = DataFrameIngestor(ingestor=Ingestor(frame))\n&gt;&gt;&gt; ingestor\nDataFrameIngestor(\n  (ingestor): Ingestor(shape=(5, 3))\n)\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/data/#arkas.data.ingestor.Ingestor","title":"arkas.data.ingestor.Ingestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a simple data ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.data.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor(\n...     data={\"pred\": np.array([3, 2, 0, 1, 0]), \"target\": np.array([3, 2, 0, 1, 0])}\n... )\n&gt;&gt;&gt; ingestor\nIngestor(num_items=2)\n&gt;&gt;&gt; data = ingestor.ingest()\n&gt;&gt;&gt; data\n{'pred': array([3, 2, 0, 1, 0]), 'target': array([3, 2, 0, 1, 0])}\n</code></pre>"},{"location":"refs/data/#arkas.data.ingestor.is_ingestor_config","title":"arkas.data.ingestor.is_ingestor_config","text":"<pre><code>is_ingestor_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseIngestor</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseIngestor</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.data.ingestor import is_ingestor_config\n&gt;&gt;&gt; is_ingestor_config({\"_target_\": \"arkas.data.ingestor.DataFrameIngestor\"})\nTrue\n</code></pre>"},{"location":"refs/data/#arkas.data.ingestor.setup_ingestor","title":"arkas.data.ingestor.setup_ingestor","text":"<pre><code>setup_ingestor(\n    ingestor: BaseIngestor | dict,\n) -&gt; BaseIngestor\n</code></pre> <p>Set up an ingestor.</p> <p>The ingestor is instantiated from its configuration by using the <code>BaseIngestor</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>Specifies an ingestor or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseIngestor</code> <p>An instantiated ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from arkas.data.ingestor import setup_ingestor\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = setup_ingestor(\n...     {\n...         \"_target_\": \"arkas.data.ingestor.DataFrameIngestor\",\n...         \"ingestor\": Ingestor(pl.DataFrame()),\n...     }\n... )\n&gt;&gt;&gt; ingestor\nDataFrameIngestor(\n  (ingestor): Ingestor(shape=(0, 0))\n)\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer","title":"arkas.data.transformer","text":"<p>Contain the data transformers.</p>"},{"location":"refs/data/#arkas.data.transformer.BaseTransformer","title":"arkas.data.transformer.BaseTransformer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to transform data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; from arkas.data.transformer import DataFrameTransformer\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = DataFrameTransformer(\n...     transformer=Cast(columns=[\"col2\"], dtype=pl.Int64), in_key=\"frame\", out_key=\"frame\"\n... )\n&gt;&gt;&gt; transformer\nDataFrameTransformer(\n  (transformer): CastTransformer(columns=('col2',), dtype=Int64, ignore_missing=False)\n  (in_key): frame\n  (out_key): frame\n)\n&gt;&gt;&gt; data = transformer.transform({\"frame\": frame})\n&gt;&gt;&gt; data\n{'frame': shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518}\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer.BaseTransformer.transform","title":"arkas.data.transformer.BaseTransformer.transform","text":"<pre><code>transform(data: dict) -&gt; dict\n</code></pre> <p>Transform the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to transform.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The transformed data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; from arkas.data.transformer import DataFrameTransformer\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = DataFrameTransformer(\n...     transformer=Cast(columns=[\"col2\"], dtype=pl.Int64), in_key=\"frame\", out_key=\"frame\"\n... )\n&gt;&gt;&gt; data = transformer.transform({\"frame\": frame})\n&gt;&gt;&gt; data\n{'frame': shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518}\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer.ColumnToArrayTransformer","title":"arkas.data.transformer.ColumnToArrayTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a data transformer that takes a column from a DataFrame and convert it to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The column name to extract.</p> required <code>in_key</code> <code>str</code> <p>The key of the DataFrame in the input dictionary.</p> required <code>out_key</code> <code>str</code> <p>The key of the array in the output dictionary.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; from arkas.data.transformer import ColumnToArrayTransformer\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = ColumnToArrayTransformer(col=\"col1\", in_key=\"frame\", out_key=\"label\")\n&gt;&gt;&gt; transformer\nColumnToArrayTransformer(col='col1', in_key='frame', out_key='label')\n&gt;&gt;&gt; data = transformer.transform({\"frame\": frame})\n&gt;&gt;&gt; data\n{'frame': shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518, 'label': array([1, 2, 3, 4, 5])}\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer.DataFrameTransformer","title":"arkas.data.transformer.DataFrameTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a data transformer to transform a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>The DataFrame transformer or its configuration.</p> required <code>in_key</code> <code>str</code> <p>The key of the DataFrame to transform in the input dictionary.</p> required <code>out_key</code> <code>str</code> <p>The key of the transformed DataFrame in the output dictionary.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; from arkas.data.transformer import DataFrameTransformer\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = DataFrameTransformer(\n...     transformer=Cast(columns=[\"col2\"], dtype=pl.Int64), in_key=\"frame\", out_key=\"frame\"\n... )\n&gt;&gt;&gt; transformer\nDataFrameTransformer(\n  (transformer): CastTransformer(columns=('col2',), dtype=Int64, ignore_missing=False)\n  (in_key): frame\n  (out_key): frame\n)\n&gt;&gt;&gt; data = transformer.transform({\"frame\": frame})\n&gt;&gt;&gt; data\n{'frame': shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518}\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer.is_transformer_config","title":"arkas.data.transformer.is_transformer_config","text":"<pre><code>is_transformer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseTransformer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseTransformer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.data.transformer import is_transformer_config\n&gt;&gt;&gt; is_transformer_config({\"_target_\": \"arkas.data.transformer.DataFrameTransformer\"})\nTrue\n</code></pre>"},{"location":"refs/data/#arkas.data.transformer.setup_transformer","title":"arkas.data.transformer.setup_transformer","text":"<pre><code>setup_transformer(\n    transformer: BaseTransformer | dict,\n) -&gt; BaseTransformer\n</code></pre> <p>Set up a data transformer.</p> <p>The transformer is instantiated from its configuration by using the <code>BaseTransformer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>A data transformer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseTransformer</code> <p>An instantiated transformer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from arkas.data.transformer import setup_transformer\n&gt;&gt;&gt; transformer = setup_transformer(\n...     {\n...         \"_target_\": \"arkas.data.transformer.DataFrameTransformer\",\n...         \"transformer\": {\n...             \"_target_\": \"grizz.transformer.Cast\",\n...             \"columns\": (\"col1\", \"col3\"),\n...             \"dtype\": pl.Int32,\n...         },\n...         \"in_key\": \"frame\",\n...         \"out_key\": \"frame\",\n...     }\n... )\n&gt;&gt;&gt; transformer\nDataFrameTransformer(\n  (transformer): CastTransformer(columns=('col1', 'col3'), dtype=Int32, ignore_missing=False)\n  (in_key): frame\n  (out_key): frame\n)\n</code></pre>"},{"location":"refs/evaluator/","title":"arkas.evaluator","text":""},{"location":"refs/evaluator/#arkas.evaluator","title":"arkas.evaluator","text":"<p>Contain evaluators.</p>"},{"location":"refs/evaluator/#arkas.evaluator.AccuracyEvaluator","title":"arkas.evaluator.AccuracyEvaluator","text":"<p>               Bases: <code>BaseLazyEvaluator</code></p> <p>Implement the accuracy evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>str</code> <p>The key or column name of the ground truth target labels.</p> required <code>y_pred</code> <code>str</code> <p>The key or column name of the predicted labels.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from arkas.evaluator import AccuracyEvaluator\n&gt;&gt;&gt; data = {\"pred\": np.array([3, 2, 0, 1, 0]), \"target\": np.array([3, 2, 0, 1, 0])}\n&gt;&gt;&gt; evaluator = AccuracyEvaluator(y_true=\"target\", y_pred=\"pred\")\n&gt;&gt;&gt; evaluator\nAccuracyEvaluator(y_true=target, y_pred=pred)\n&gt;&gt;&gt; result = evaluator.evaluate(data)\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n&gt;&gt;&gt; frame = pl.DataFrame({\"pred\": [3, 2, 0, 1, 0, 1], \"target\": [3, 2, 0, 1, 0, 1]})\n&gt;&gt;&gt; result = evaluator.evaluate(frame)\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(6,), y_pred=(6,))\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.AveragePrecisionEvaluator","title":"arkas.evaluator.AveragePrecisionEvaluator","text":"<p>               Bases: <code>BaseLazyEvaluator</code></p> <p>Implement the average precision evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>str</code> <p>The key or column name of the ground truth target labels.</p> required <code>y_score</code> <code>str</code> <p>The key or column name of the predicted labels.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, <code>'multilabel'</code>, and <code>'auto'</code>. If <code>'auto'</code>, it tries to automatically find the label type from the arrays' shape.</p> <code>'auto'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from arkas.evaluator import AveragePrecisionEvaluator\n&gt;&gt;&gt; data = {\"pred\": np.array([2, -1, 0, 3, 1]), \"target\": np.array([1, 0, 0, 1, 1])}\n&gt;&gt;&gt; evaluator = AveragePrecisionEvaluator(y_true=\"target\", y_score=\"pred\")\n&gt;&gt;&gt; evaluator\nAveragePrecisionEvaluator(y_true=target, y_score=pred, label_type=auto)\n&gt;&gt;&gt; result = evaluator.evaluate(data)\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(5,), y_score=(5,), label_type=binary)\n&gt;&gt;&gt; frame = pl.DataFrame({\"pred\": [2, -1, 0, 3, 1], \"target\": [1, 0, 0, 1, 1]})\n&gt;&gt;&gt; result = evaluator.evaluate(frame)\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(5,), y_score=(5,), label_type=binary)\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.BaseEvaluator","title":"arkas.evaluator.BaseEvaluator","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to evaluate a DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.evaluator import AccuracyEvaluator\n&gt;&gt;&gt; data = {\"pred\": np.array([3, 2, 0, 1, 0]), \"target\": np.array([3, 2, 0, 1, 0])}\n&gt;&gt;&gt; evaluator = AccuracyEvaluator(y_true=\"target\", y_pred=\"pred\")\n&gt;&gt;&gt; evaluator\nAccuracyEvaluator(y_true=target, y_pred=pred)\n&gt;&gt;&gt; result = evaluator.evaluate(data)\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.BaseEvaluator.evaluate","title":"arkas.evaluator.BaseEvaluator.evaluate","text":"<pre><code>evaluate(\n    data: dict | DataFrame, lazy: bool = True\n) -&gt; BaseResult\n</code></pre> <p>Evaluate the results.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | DataFrame</code> <p>The data to evaluate.</p> required <code>lazy</code> <code>bool</code> <p>If <code>False</code>, it forces the computation of the results, otherwise it tries to</p> <code>True</code> <p>Returns:</p> Type Description <code>BaseResult</code> <p>The generated results.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.evaluator import AccuracyEvaluator\n&gt;&gt;&gt; data = {\"pred\": np.array([3, 2, 0, 1, 0]), \"target\": np.array([3, 2, 0, 1, 0])}\n&gt;&gt;&gt; evaluator = AccuracyEvaluator(y_true=\"target\", y_pred=\"pred\")\n&gt;&gt;&gt; result = evaluator.evaluate(data)\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.BaseLazyEvaluator","title":"arkas.evaluator.BaseLazyEvaluator","text":"<p>               Bases: <code>BaseEvaluator</code></p> <p>Define the base class to evaluate a DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.evaluator import AccuracyEvaluator\n&gt;&gt;&gt; data = {\"pred\": np.array([3, 2, 0, 1, 0]), \"target\": np.array([3, 2, 0, 1, 0])}\n&gt;&gt;&gt; evaluator = AccuracyEvaluator(y_true=\"target\", y_pred=\"pred\")\n&gt;&gt;&gt; evaluator\nAccuracyEvaluator(y_true=target, y_pred=pred)\n&gt;&gt;&gt; result = evaluator.evaluate(data)\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.is_evaluator_config","title":"arkas.evaluator.is_evaluator_config","text":"<pre><code>is_evaluator_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseEvaluator</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseEvaluator</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.evaluator import is_evaluator_config\n&gt;&gt;&gt; is_evaluator_config({\"_target_\": \"arkas.evaluator.AccuracyEvaluator\"})\nTrue\n</code></pre>"},{"location":"refs/evaluator/#arkas.evaluator.setup_evaluator","title":"arkas.evaluator.setup_evaluator","text":"<pre><code>setup_evaluator(\n    evaluator: BaseEvaluator | dict,\n) -&gt; BaseEvaluator\n</code></pre> <p>Set up an evaluator.</p> <p>The evaluator is instantiated from its configuration by using the <code>BaseEvaluator</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>evaluator</code> <code>BaseEvaluator | dict</code> <p>Specifies an evaluator or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseEvaluator</code> <p>An instantiated evaluator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.evaluator import setup_evaluator\n&gt;&gt;&gt; evaluator = setup_evaluator(\n...     {\n...         \"_target_\": \"arkas.evaluator.AccuracyEvaluator\",\n...         \"y_true\": \"target\",\n...         \"y_pred\": \"pred\",\n...     }\n... )\n&gt;&gt;&gt; evaluator\nAccuracyEvaluator(y_true=target, y_pred=pred)\n</code></pre>"},{"location":"refs/metric/","title":"arkas.metric","text":""},{"location":"refs/metric/#arkas.metric","title":"arkas.metric","text":"<p>Contain functions to compute metrics.</p>"},{"location":"refs/metric/#arkas.metric.accuracy_metrics","title":"arkas.metric.accuracy_metrics","text":"<pre><code>accuracy_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import accuracy_metrics\n&gt;&gt;&gt; accuracy_metrics(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.average_precision_metrics","title":"arkas.metric.average_precision_metrics","text":"<pre><code>average_precision_metrics(\n    y_true: ndarray,\n    y_score: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the average precision metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import average_precision_metrics\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; metrics = average_precision_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_score=np.array([2, -1, 0, 3, 1])\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': 1.0, 'count': 5}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; metrics = average_precision_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n...     label_type=\"binary\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': 1.0, 'count': 5}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; metrics = average_precision_metrics(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_score=np.array(\n...         [\n...             [0.7, 0.2, 0.1],\n...             [0.4, 0.3, 0.3],\n...             [0.1, 0.8, 0.1],\n...             [0.2, 0.3, 0.5],\n...             [0.4, 0.4, 0.2],\n...             [0.1, 0.2, 0.7],\n...         ]\n...     ),\n...     label_type=\"multiclass\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([0.833..., 0.75 , 0.75 ]),\n 'count': 6,\n 'macro_average_precision': 0.777...,\n 'micro_average_precision': 0.75,\n 'weighted_average_precision': 0.777...}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; metrics = average_precision_metrics(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_score=np.array([[2, -1, -1], [-1, 1, 2], [0, 2, 3], [3, -2, -4], [1, -3, -5]]),\n...     label_type=\"multilabel\",\n... )\n&gt;&gt;&gt; metrics\n{'average_precision': array([1. , 1. , 0.477...]),\n 'count': 5,\n 'macro_average_precision': 0.825...,\n 'micro_average_precision': 0.588...,\n 'weighted_average_precision': 0.804...}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.balanced_accuracy_metrics","title":"arkas.metric.balanced_accuracy_metrics","text":"<pre><code>balanced_accuracy_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import balanced_accuracy_metrics\n&gt;&gt;&gt; balanced_accuracy_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n{'balanced_accuracy': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.precision_metrics","title":"arkas.metric.precision_metrics","text":"<pre><code>precision_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the precision metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import precision_metrics\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; precision_metrics(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.accuracy","title":"arkas.metric.accuracy","text":"<p>Implement accuracy metrics.</p>"},{"location":"refs/metric/#arkas.metric.accuracy.accuracy_metrics","title":"arkas.metric.accuracy.accuracy_metrics","text":"<pre><code>accuracy_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import accuracy_metrics\n&gt;&gt;&gt; accuracy_metrics(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.accuracy.balanced_accuracy_metrics","title":"arkas.metric.accuracy.balanced_accuracy_metrics","text":"<pre><code>balanced_accuracy_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import balanced_accuracy_metrics\n&gt;&gt;&gt; balanced_accuracy_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n{'balanced_accuracy': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.precision","title":"arkas.metric.precision","text":"<p>Implement the precision result.</p>"},{"location":"refs/metric/#arkas.metric.precision.find_label_type","title":"arkas.metric.precision.find_label_type","text":"<pre><code>find_label_type(y_true: ndarray, y_pred: ndarray) -&gt; str\n</code></pre> <p>Try to find the label type automatically based on the arrays' shape and values.</p> Note <p>NaN are used to indicate invalid/missing values.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The label type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric.precision import find_label_type\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; label_type = find_label_type(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; label_type\n'binary'\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; label_type = find_label_type(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]), y_pred=np.array([0, 0, 1, 1, 2, 2])\n... )\n&gt;&gt;&gt; label_type\n'multiclass'\n</code></pre>"},{"location":"refs/metric/#arkas.metric.precision.precision_metrics","title":"arkas.metric.precision.precision_metrics","text":"<pre><code>precision_metrics(\n    y_true: ndarray,\n    y_pred: ndarray,\n    *,\n    label_type: str = \"auto\",\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the precision metrics.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, and <code>'multilabel'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>.</p> <code>'auto'</code> <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The computed metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric import precision_metrics\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; precision_metrics(y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1]))\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n{'count': 6,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; precision_metrics(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     label_type=\"multilabel\",\n... )\n{'count': 5,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n</code></pre>"},{"location":"refs/metric/#arkas.metric.utils","title":"arkas.metric.utils","text":"<p>Contain utility functions to compute metrics.</p>"},{"location":"refs/metric/#arkas.metric.utils.multi_isnan","title":"arkas.metric.utils.multi_isnan","text":"<pre><code>multi_isnan(arrays: Sequence[ndarray]) -&gt; ndarray\n</code></pre> <p>Test element-wise for NaN for all input arrays and return result as a boolean array.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[ndarray]</code> <p>The input arrays to test. All the arrays must have the same shape.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A boolean array. <code>True</code> where any array is NaN, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.metric.utils import multi_isnan\n&gt;&gt;&gt; mask = multi_isnan(\n...     [np.array([1, 0, 0, 1, float(\"nan\")]), np.array([1, float(\"nan\"), 0, 1, 1])]\n... )\n&gt;&gt;&gt; mask\narray([False,  True, False, False,  True])\n</code></pre>"},{"location":"refs/result/","title":"arkas.result","text":""},{"location":"refs/result/#arkas.result","title":"arkas.result","text":"<p>Contain results.</p>"},{"location":"refs/result/#arkas.result.AccuracyResult","title":"arkas.result.AccuracyResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the accuracy result.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; result = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.AveragePrecisionResult","title":"arkas.result.AveragePrecisionResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the average precision result.</p> <p>This result can be used in 3 different settings:</p> <ul> <li>binary: <code>y_true</code> must be an array of shape <code>(*)</code>     with <code>0</code> and <code>1</code> values, and <code>y_score</code> must be an array     of shape <code>(*)</code>.</li> <li>multiclass: <code>y_true</code> must be an array of shape <code>(n_samples,)</code>     with values in <code>{0, ..., n_classes-1}</code>, and <code>y_score</code> must     be an array of shape <code>(n_samples, n_classes)</code>.</li> <li>multilabel: <code>y_true</code> must be an array of shape     <code>(n_samples, n_classes)</code> with <code>0</code> and <code>1</code> values, and     <code>y_score</code> must be an array of shape     <code>(n_samples, n_classes)</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_score</code> <code>ndarray</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>label_type</code> <code>str</code> <p>The type of labels used to evaluate the metrics. The valid values are: <code>'binary'</code>, <code>'multiclass'</code>, <code>'multilabel'</code>, and <code>'auto'</code>. If <code>'binary'</code> or <code>'multilabel'</code>, <code>y_true</code> values  must be <code>0</code> and <code>1</code>. If <code>'auto'</code>, it tries to automatically find the label type from the arrays' shape.</p> <code>'auto'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AveragePrecisionResult\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; result = AveragePrecisionResult(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n...     label_type=\"binary\",\n... )\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(5,), y_score=(5,), label_type=binary)\n&gt;&gt;&gt; result.compute_metrics()\n{'average_precision': 1.0, 'count': 5}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; result = AveragePrecisionResult(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_score=np.array([[2, -1, -1], [-1, 1, 2], [0, 2, 3], [3, -2, -4], [1, -3, -5]]),\n...     label_type=\"multilabel\",\n... )\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(5, 3), y_score=(5, 3), label_type=multilabel)\n&gt;&gt;&gt; result.compute_metrics()\n{'average_precision': array([1. , 1. , 0.477...]),\n 'count': 5,\n 'macro_average_precision': 0.825...,\n 'micro_average_precision': 0.588...,\n 'weighted_average_precision': 0.804...}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; result = AveragePrecisionResult(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_score=np.array(\n...         [\n...             [0.7, 0.2, 0.1],\n...             [0.4, 0.3, 0.3],\n...             [0.1, 0.8, 0.1],\n...             [0.2, 0.3, 0.5],\n...             [0.4, 0.4, 0.2],\n...             [0.1, 0.2, 0.7],\n...         ]\n...     ),\n...     label_type=\"multiclass\",\n... )\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(6,), y_score=(6, 3), label_type=multiclass)\n&gt;&gt;&gt; result.compute_metrics()\n{'average_precision': array([0.833..., 0.75 , 0.75 ]),\n 'count': 6,\n 'macro_average_precision': 0.777...,\n 'micro_average_precision': 0.75,\n 'weighted_average_precision': 0.777...}\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; result = AveragePrecisionResult(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n... )\n&gt;&gt;&gt; result\nAveragePrecisionResult(y_true=(5,), y_score=(5,), label_type=binary)\n&gt;&gt;&gt; result.compute_metrics()\n{'average_precision': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/result/#arkas.result.BalancedAccuracyResult","title":"arkas.result.BalancedAccuracyResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the balanced accuracy result.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> where the values are in <code>{0, ..., n_classes-1}</code>.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; result = BalancedAccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result\nBalancedAccuracyResult(y_true=(5,), y_pred=(5,))\n&gt;&gt;&gt; result.compute_metrics()\n{'balanced_accuracy': 1.0, 'count': 5}\n</code></pre>"},{"location":"refs/result/#arkas.result.BaseResult","title":"arkas.result.BaseResult","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to manage results.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; result = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result\nAccuracyResult(y_true=(5,), y_pred=(5,))\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.BaseResult.compute_metrics","title":"arkas.result.BaseResult.compute_metrics  <code>abstractmethod</code>","text":"<pre><code>compute_metrics(prefix: str = '', suffix: str = '') -&gt; dict\n</code></pre> <p>Return the metrics associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>The metrics.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; result = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 1.0, 'count_correct': 5, 'count_incorrect': 0, 'count': 5, 'error': 0.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.BaseResult.equal","title":"arkas.result.BaseResult.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two results are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other result to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two results are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; res1 = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; res2 = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; res3 = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 0, 0]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; res1.equal(res2)\nTrue\n&gt;&gt;&gt; res1.equal(res3)\nFalse\n</code></pre>"},{"location":"refs/result/#arkas.result.BaseResult.generate_figures","title":"arkas.result.BaseResult.generate_figures  <code>abstractmethod</code>","text":"<pre><code>generate_figures(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict\n</code></pre> <p>Return the figures associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>The figures.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; result = AccuracyResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result.generate_figures()\n{}\n</code></pre>"},{"location":"refs/result/#arkas.result.BinaryClassificationResult","title":"arkas.result.BinaryClassificationResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the default binary classification result.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target binary labels. This input must be an array of shape <code>(n_samples,)</code> where the values are <code>0</code> or <code>1</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted binary labels. This input must be an array of shape <code>(n_samples,)</code> where the values are <code>0</code> or <code>1</code>.</p> required <code>y_score</code> <code>ndarray | None</code> <p>The target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions.</p> <code>None</code> <code>f1_betas</code> <code>Sequence[float]</code> <p>The betas used to compute the F-beta scores.</p> <code>(1)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import BinaryClassificationResult\n&gt;&gt;&gt; result = BinaryClassificationResult(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     y_score=np.array([2, -1, 0, 3, 1]),\n... )\n&gt;&gt;&gt; result\nBinaryClassificationResult(\n  (y_true): (5,)\n  (y_pred): (5,)\n  (y_score): (5,)\n  (f1_betas): (1,)\n)\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 1.0,\n 'balanced_accuracy': 1.0,\n 'precision': 1.0,\n 'recall': 1.0,\n 'jaccard': 1.0,\n 'count': 5,\n 'count_correct': 5,\n 'count_incorrect': 0,\n 'false_negative_rate': 0.0,\n 'false_negative': 0,\n 'false_positive_rate': 0.0,\n 'false_positive': 0,\n 'true_negative_rate': 1.0,\n 'true_negative': 2,\n 'true_positive_rate': 1.0,\n 'true_positive': 3,\n 'f1': 1.0,\n 'average_precision': 1.0,\n 'roc_auc': 1.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.BinaryClassificationResult.compute_base_metrics","title":"arkas.result.BinaryClassificationResult.compute_base_metrics","text":"<pre><code>compute_base_metrics(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the base metrics associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The metrics.</p>"},{"location":"refs/result/#arkas.result.BinaryClassificationResult.compute_confmat_metrics","title":"arkas.result.BinaryClassificationResult.compute_confmat_metrics","text":"<pre><code>compute_confmat_metrics(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the confusion matrix-based metrics associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The metrics.</p>"},{"location":"refs/result/#arkas.result.BinaryClassificationResult.compute_fbeta_metrics","title":"arkas.result.BinaryClassificationResult.compute_fbeta_metrics","text":"<pre><code>compute_fbeta_metrics(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the F-beta metrics associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The metrics.</p>"},{"location":"refs/result/#arkas.result.BinaryClassificationResult.compute_rank_metrics","title":"arkas.result.BinaryClassificationResult.compute_rank_metrics","text":"<pre><code>compute_rank_metrics(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, float]\n</code></pre> <p>Return the ranking-based metrics associated to the result.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The key prefix in the returned dictionary.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The key suffix in the returned dictionary.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The metrics.</p>"},{"location":"refs/result/#arkas.result.EmptyResult","title":"arkas.result.EmptyResult","text":"<p>               Bases: <code>Result</code></p> <p>Implement an empty result.</p> <p>This result is designed to be used when it is possible to evaluate a result.</p>"},{"location":"refs/result/#arkas.result.MergedResult","title":"arkas.result.MergedResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement a result to merge multiple result objects into a single result object.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Sequence[BaseResult]</code> <p>The results to merge. This order is used to merge the metrics and figures if they have duplicate keys, i.e. only the last value for each key is kept.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import MergedResult, Result\n&gt;&gt;&gt; result = MergedResult(\n...     [\n...         Result(metrics={\"accuracy\": 62.0, \"count\": 42}),\n...         Result(metrics={\"ap\": 0.42, \"count\": 42}),\n...     ]\n... )\n&gt;&gt;&gt; result\nMergedResult(count=2)\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 62.0, 'count': 42, 'ap': 0.42}\n</code></pre>"},{"location":"refs/result/#arkas.result.PrecisionResult","title":"arkas.result.PrecisionResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the precision result.</p> <p>This result can be used in 3 different settings:</p> <ul> <li>binary: <code>y_true</code> must be an array of shape <code>(n_samples,)</code>     with <code>0</code> and <code>1</code> values, and <code>y_pred</code> must be an array     of shape <code>(n_samples,)</code>.</li> <li>multiclass: <code>y_true</code> must be an array of shape <code>(n_samples,)</code>     with values in <code>{0, ..., n_classes-1}</code>, and <code>y_pred</code> must     be an array of shape <code>(n_samples,)</code>.</li> <li>multilabel: <code>y_true</code> must be an array of shape     <code>(n_samples, n_classes)</code> with <code>0</code> and <code>1</code> values, and     <code>y_pred</code> must be an array of shape     <code>(n_samples, n_classes)</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import PrecisionResult\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; result = PrecisionResult(\n...     y_true=np.array([1, 0, 0, 1, 1]),\n...     y_pred=np.array([1, 0, 0, 1, 1]),\n...     label_type=\"binary\",\n... )\n&gt;&gt;&gt; result\nPrecisionResult(y_true=(5,), y_pred=(5,), label_type=binary)\n&gt;&gt;&gt; result.compute_metrics()\n{'count': 5, 'precision': 1.0}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; result = PrecisionResult(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1], [1, 0, 0], [1, 0, 0]]),\n...     label_type=\"multilabel\",\n... )\n&gt;&gt;&gt; result\nPrecisionResult(y_true=(5, 3), y_pred=(5, 3), label_type=multilabel)\n&gt;&gt;&gt; result.compute_metrics()\n{'count': 5,\n 'macro_precision': 0.666...,\n 'micro_precision': 0.714...,\n 'precision': array([1., 1., 0.]),\n 'weighted_precision': 0.625}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; result = PrecisionResult(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n...     label_type=\"multiclass\",\n... )\n&gt;&gt;&gt; result\nPrecisionResult(y_true=(6,), y_pred=(6,), label_type=multiclass)\n&gt;&gt;&gt; result.compute_metrics()\n{'count': 6,\n 'macro_precision': 1.0,\n 'micro_precision': 1.0,\n 'precision': array([1., 1., 1.]),\n 'weighted_precision': 1.0}\n&gt;&gt;&gt; # auto\n&gt;&gt;&gt; result = PrecisionResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result\nPrecisionResult(y_true=(5,), y_pred=(5,), label_type=binary)\n&gt;&gt;&gt; result.compute_metrics()\n{'count': 5, 'precision': 1.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.RecallResult","title":"arkas.result.RecallResult","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement the recall result.</p> <p>This result can be used in 3 different settings:</p> <ul> <li>binary: <code>y_true</code> must be an array of shape <code>(n_samples,)</code>     with <code>0</code> and <code>1</code> values, and <code>y_pred</code> must be an array     of shape <code>(n_samples,)</code>.</li> <li>multiclass: <code>y_true</code> must be an array of shape <code>(n_samples,)</code>     with values in <code>{0, ..., n_classes-1}</code>, and <code>y_pred</code> must     be an array of shape <code>(n_samples,)</code>.</li> <li>multilabel: <code>y_true</code> must be an array of shape     <code>(n_samples, n_classes)</code> with <code>0</code> and <code>1</code> values, and     <code>y_pred</code> must be an array of shape     <code>(n_samples, n_classes)</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>The ground truth target labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <code>y_pred</code> <code>ndarray</code> <p>The predicted labels. This input must be an array of shape <code>(n_samples,)</code> or <code>(n_samples, n_classes)</code>.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.result import RecallResult\n&gt;&gt;&gt; # binary\n&gt;&gt;&gt; result = RecallResult(\n...     y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n... )\n&gt;&gt;&gt; result\nRecallResult(y_true=(5,), y_pred=(5,))\n&gt;&gt;&gt; result.compute_metrics()\n{'recall': 1.0, 'count': 5}\n&gt;&gt;&gt; # multilabel\n&gt;&gt;&gt; result = RecallResult(\n...     y_true=np.array([[1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]]),\n...     y_pred=np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1], [1, 0, 0], [1, 0, 0]]),\n... )\n&gt;&gt;&gt; result\nRecallResult(y_true=(5, 3), y_pred=(5, 3))\n&gt;&gt;&gt; result.compute_metrics()\n{'recall': array([1., 1., 0.]),\n 'count': 5,\n 'macro_recall': 0.666...,\n 'micro_recall': 0.625,\n 'weighted_recall': 0.625}\n&gt;&gt;&gt; # multiclass\n&gt;&gt;&gt; result = RecallResult(\n...     y_true=np.array([0, 0, 1, 1, 2, 2]),\n...     y_pred=np.array([0, 0, 1, 1, 2, 2]),\n... )\n&gt;&gt;&gt; result\nRecallResult(y_true=(6,), y_pred=(6,))\n&gt;&gt;&gt; result.compute_metrics()\n{'recall': array([1., 1., 1.]),\n 'count': 6,\n 'macro_recall': 1.0,\n 'micro_recall': 1.0,\n 'weighted_recall': 1.0}\n</code></pre>"},{"location":"refs/result/#arkas.result.Result","title":"arkas.result.Result","text":"<p>               Bases: <code>BaseResult</code></p> <p>Implement a simple result.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>dict | None</code> <p>The metrics.</p> <code>None</code> <code>figures</code> <code>dict | None</code> <p>The figures.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.result import Result\n&gt;&gt;&gt; result = Result(metrics={\"accuracy\": 1.0, \"count\": 42}, figures={})\n&gt;&gt;&gt; result\nResult(metrics=2, figures=0)\n&gt;&gt;&gt; result.compute_metrics()\n{'accuracy': 1.0, 'count': 42}\n</code></pre>"},{"location":"refs/section/","title":"arkas.section","text":""},{"location":"refs/section/#arkas.section","title":"arkas.section","text":"<p>Contain sections.</p>"},{"location":"refs/section/#arkas.section.AccuracySection","title":"arkas.section.AccuracySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyze accuracy results.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from arkas.section import AccuracySection\n&gt;&gt;&gt; from arkas.result import AccuracyResult\n&gt;&gt;&gt; section = AccuracySection(\n...     result=AccuracyResult(\n...         y_true=np.array([1, 0, 0, 1, 1]), y_pred=np.array([1, 0, 0, 1, 1])\n...     )\n... )\n&gt;&gt;&gt; section\nAccuracySection(\n  (result): AccuracyResult(y_true=(5,), y_pred=(5,))\n)\n&gt;&gt;&gt; section.generate_html_body()\n</code></pre>"},{"location":"refs/section/#arkas.section.BaseSection","title":"arkas.section.BaseSection","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to manage sections.</p>"},{"location":"refs/section/#arkas.section.BaseSection.equal","title":"arkas.section.BaseSection.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two sections are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other section to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two sections are equal, otherwise <code>False</code>.</p>"},{"location":"refs/section/#arkas.section.BaseSection.generate_html_body","title":"arkas.section.BaseSection.generate_html_body  <code>abstractmethod</code>","text":"<pre><code>generate_html_body(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n) -&gt; str\n</code></pre> <p>Return the HTML body associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML body associated to the section.</p>"},{"location":"refs/section/#arkas.section.BaseSection.generate_html_toc","title":"arkas.section.BaseSection.generate_html_toc  <code>abstractmethod</code>","text":"<pre><code>generate_html_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p>"},{"location":"refs/section/#arkas.section.ContentSection","title":"arkas.section.ContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.section import ContentSection\n&gt;&gt;&gt; section = ContentSection(content=\"meow\")\n&gt;&gt;&gt; section\nContentSection()\n&gt;&gt;&gt; section.generate_html_body()\n</code></pre>"},{"location":"refs/utils/","title":"arkas.utils","text":""},{"location":"refs/utils/#arkas.utils","title":"arkas.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#arkas.utils.factory","title":"arkas.utils.factory","text":"<p>Contain a function to instantiate an object from its configuration.</p>"},{"location":"refs/utils/#arkas.utils.factory.setup_object","title":"arkas.utils.factory.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.factory import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"},{"location":"refs/utils/#arkas.utils.figure","title":"arkas.utils.figure","text":"<p>Contain utility functions to manage matplotlib figures.</p>"},{"location":"refs/utils/#arkas.utils.figure.figure2html","title":"arkas.utils.figure.figure2html","text":"<pre><code>figure2html(\n    fig: Figure | None,\n    reactive: bool = True,\n    close_fig: bool = False,\n) -&gt; str\n</code></pre> <p>Convert a matplotlib figure to a string that can be used in a HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | None</code> <p>The figure to convert.</p> required <code>reactive</code> <code>bool</code> <p>If <code>True</code>, the generated is configured to be reactive to the screen size.</p> <code>True</code> <code>close_fig</code> <code>bool</code> <p>If <code>True</code>, the figure is closed after it is converted to HTML format.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The converted figure to a string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from arkas.utils.figure import figure2html\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; string = figure2html(fig)\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports","title":"arkas.utils.imports","text":"<p>Implement some utility functions to manage optional dependencies.</p>"},{"location":"refs/utils/#arkas.utils.imports.check_colorlog","title":"arkas.utils.imports.check_colorlog","text":"<pre><code>check_colorlog() -&gt; None\n</code></pre> <p>Check if the <code>colorlog</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>colorlog</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import check_colorlog\n&gt;&gt;&gt; check_colorlog()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports.check_markdown","title":"arkas.utils.imports.check_markdown","text":"<pre><code>check_markdown() -&gt; None\n</code></pre> <p>Check if the <code>markdown</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>markdown</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import check_markdown\n&gt;&gt;&gt; check_markdown()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports.colorlog_available","title":"arkas.utils.imports.colorlog_available","text":"<pre><code>colorlog_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>colorlog</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>colorlog</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import colorlog_available\n&gt;&gt;&gt; @colorlog_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports.is_colorlog_available","title":"arkas.utils.imports.is_colorlog_available","text":"<pre><code>is_colorlog_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>colorlog</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>colorlog</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import is_colorlog_available\n&gt;&gt;&gt; is_colorlog_available()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports.is_markdown_available","title":"arkas.utils.imports.is_markdown_available","text":"<pre><code>is_markdown_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>markdown</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>markdown</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import is_markdown_available\n&gt;&gt;&gt; is_markdown_available()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.imports.markdown_available","title":"arkas.utils.imports.markdown_available","text":"<pre><code>markdown_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>markdown</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>markdown</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.imports import markdown_available\n&gt;&gt;&gt; @markdown_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#arkas.utils.text","title":"arkas.utils.text","text":"<p>Contain text utility functions.</p>"},{"location":"refs/utils/#arkas.utils.text.markdown_to_html","title":"arkas.utils.text.markdown_to_html","text":"<pre><code>markdown_to_html(\n    text: str, ignore_error: bool = False\n) -&gt; str\n</code></pre> <p>Convert a markdown text to HTML text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The markdown text to convert.</p> required <code>ignore_error</code> <code>bool</code> <p>If <code>False</code>, an error is raised if <code>markdown</code> is not installed, otherwise the input text is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The converted text if <code>markdown</code> is installed, otherwise the input text.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from arkas.utils.text import markdown_to_html\n&gt;&gt;&gt; out = markdown_to_html(\"- a\\n- b\\n- c\")\n&gt;&gt;&gt; print(out)\n&lt;ul&gt;\n&lt;li&gt;a&lt;/li&gt;\n&lt;li&gt;b&lt;/li&gt;\n&lt;li&gt;c&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"}]}